#!/bin/bash
# ==============================================================================
# PRE-COMMIT HOOK - UNIVERSAL INTELLIGENT SECRETS SCANNER + AI PROTECTION
# AI Workflow Rules Framework v9.0
# ==============================================================================
#
# PHILOSOPHY: Silent Guardian Architecture
#   Protect without blocking productivity
#   Trust informed decisions
#   Universal compatibility (all IDEs, all AI providers, all platforms)
#
# SECURITY APPROACH: 3-Tier Protection + AI Protection
#   Tier 1: HARD BLOCK - Real secrets (100% confidence)
#   Tier 2: WARNING + CHOICE - Suspicious patterns (let user decide)
#   Tier 3: SILENT - Legitimate cases (context-aware)
#   ğŸ†• AI Protection: Prompt injection + PII detection + Fail-closed hooks
#
# SUPPORTED AI PROVIDERS:
#   Anthropic (Claude), OpenAI (GPT), Google (Gemini), Hugging Face,
#   Cohere, Azure OpenAI, Replicate, GitHub Copilot, AWS Bedrock
#
# PLATFORM COMPATIBILITY:
#   - Linux/macOS: Native bash
#   - Windows: Git Bash (auto-installed with Git for Windows)
#   - CI/CD: Auto-detects non-interactive mode
#
# IDE COMPATIBILITY:
#   VS Code, Cursor, Windsurf, WebStorm, Sublime, Vim, all git-based IDEs
#
# BYPASS MECHANISMS:
#   - Comment: // secure-ignore or # secure-ignore
#   - File: .securityignore (gitignore syntax)
#   - Interactive: Type 'yes' for tier 2 warnings (auto-skip in CI/CD)
#   - Emergency: git commit --no-verify (disables ALL checks)
#   - Env var: SECURITY_HOOK_MODE=permissive (for CI/CD)
#
# ==============================================================================

set -e

# Colors (disabled in non-TTY environments like CI/CD)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    CYAN=''
    NC=''
fi

# Detect environment
IS_INTERACTIVE=false
IS_CI=false

# Check if running in interactive terminal
if [ -t 0 ] && [ -t 1 ]; then
    IS_INTERACTIVE=true
fi

# Detect CI/CD environment
if [ "$CI" == "true" ] || \
   [ "$GITHUB_ACTIONS" == "true" ] || \
   [ "$GITLAB_CI" == "true" ] || \
   [ "$JENKINS_HOME" != "" ] || \
   [ "$CIRCLECI" == "true" ] || \
   [ "$TRAVIS" == "true" ]; then
    IS_CI=true
    IS_INTERACTIVE=false
fi

# Environment-based mode
HOOK_MODE="${SECURITY_HOOK_MODE:-balanced}"  # strict | balanced | permissive

# Flags
HARD_BLOCKED=false
VIOLATIONS_FOUND=false
TRACKERS_FOUND=false
WARNINGS_COUNT=0

# Config
SECURITY_POLICY=".ai/security-policy.json"
SECURITY_IGNORE=".securityignore"
AUDIT_TRAIL=".ai/audit-trail.log"

# ==============================================================================
# FUNCTIONS
# ==============================================================================

print_header() {
    echo -e "${BLUE}ğŸ”’ Pre-Commit Security Scan${NC}"
    if [ "$IS_CI" == "true" ]; then
        echo -e "${CYAN}   Environment: CI/CD (non-interactive mode)${NC}"
    fi
    echo ""
}

print_error() {
    echo -e "${RED}âŒ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}âš ï¸  $1${NC}"
}

print_success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

print_info() {
    echo -e "${CYAN}â„¹ï¸  $1${NC}"
}

# Calculate Shannon entropy (detect high-randomness strings likely to be secrets)
calculate_entropy() {
    local string="$1"
    local length=${#string}

    # Skip short strings
    if [ $length -lt 20 ]; then
        echo "0"
        return
    fi

    # Use Python if available (more accurate)
    if command -v python3 &> /dev/null; then
        entropy=$(python3 -c "
import math
from collections import Counter
s = '$string'
p = [c/len(s) for c in Counter(s).values()]
entropy = -sum(pi * math.log2(pi) for pi in p)
print(f'{entropy:.2f}')
" 2>/dev/null)
        echo "${entropy:-0}"
        return
    fi

    # Fallback: Simple approximation
    # High entropy = many unique characters
    unique_chars=$(echo "$string" | grep -o . | sort -u | wc -l)
    ratio=$(echo "scale=2; $unique_chars / $length" | bc 2>/dev/null || echo "0")

    # Rough entropy estimate (0-5 scale)
    if (( $(echo "$ratio > 0.7" | bc -l 2>/dev/null || echo 0) )); then
        echo "4.5"
    elif (( $(echo "$ratio > 0.5" | bc -l 2>/dev/null || echo 0) )); then
        echo "3.5"
    else
        echo "2.0"
    fi
}

# Check if file should be ignored
is_ignored() {
    local file="$1"
    local filename=$(basename "$file")

    # Built-in whitelist
    local BUILT_IN_IGNORE=(
        ".env.example"
        ".env.sample"
        ".env.template"
        "scripts/pre-commit"
        "scripts/pre-commit.js"
        "scripts/pre-commit.ps1"
        "scripts/install.sh"
        "scripts/install.ps1"
        "scripts/sync-rules.sh"
        "bin/cli.js"
        ".git/hooks/pre-commit"
        "scripts/seo-check.sh"
        ".ai/security-policy.json"
        ".ai/ai-protection-policy.json"
        ".ai/prompt-injection-patterns.json"
        ".ai/pii-patterns.json"
        ".ai/forbidden-trackers.json"
        ".ai/token-limits.json"
        "RULES_PRODUCT.md"
        "RULES_CORE.md"
        "CHANGELOG.md"
        "node_modules/"
        "npm-templates/"
        "dist/"
        "build/"
        ".next/"
        "examples/"
        "tests/fixtures/"
        "__tests__/mocks/"
    )

    for pattern in "${BUILT_IN_IGNORE[@]}"; do
        if [[ "$file" == *"$pattern"* ]]; then
            return 0
        fi
    done

    # Check .securityignore file
    if [ -f "$SECURITY_IGNORE" ]; then
        while IFS= read -r pattern || [ -n "$pattern" ]; do
            [[ "$pattern" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$pattern" ]] && continue

            if [[ "$file" == $pattern ]]; then
                return 0
            fi
        done < "$SECURITY_IGNORE"
    fi

    return 1
}

# Check if line has bypass comment
has_bypass_comment() {
    local line="$1"

    if [[ "$line" == *"secure-ignore"* ]] || \
       [[ "$line" == *"security:ignore"* ]] || \
       [[ "$line" == *"nosecret"* ]]; then
        return 0
    fi

    return 1
}

# Log security events
log_to_audit_trail() {
    local event_type="$1"
    local details="$2"

    mkdir -p .ai

    cat >> "$AUDIT_TRAIL" << EOF
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
[$(date '+%Y-%m-%d %H:%M:%S %Z')] COMMIT BLOCKED
Event: $event_type
Details: $details
Framework: ai-workflow-rules v8.3
User: $(git config user.name) <$(git config user.email)>
Branch: $(git branch --show-current)
Environment: $([ "$IS_CI" == "true" ] && echo "CI/CD" || echo "Interactive")
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

EOF
}

# Interactive prompt (auto-skip in CI/CD)
ask_user_confirmation() {
    local message="$1"

    # In CI/CD or non-interactive mode: auto-block tier 2
    if [ "$IS_INTERACTIVE" == "false" ]; then
        print_warning "Non-interactive mode: Auto-blocking suspicious pattern"
        return 1
    fi

    # In permissive mode: auto-allow tier 2
    if [ "$HOOK_MODE" == "permissive" ]; then
        print_warning "Permissive mode: Auto-allowing (set SECURITY_HOOK_MODE=balanced)"
        return 0
    fi

    echo ""
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${YELLOW}SECURITY WARNING${NC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo "$message"
    echo ""
    echo "How to fix:"
    echo "  1. Use environment variables: process.env.API_KEY"
    echo "  2. Move to .env file (gitignored)"
    echo "  3. If false positive: add comment // secure-ignore"
    echo "  4. Skip this check: git commit --no-verify"
    echo ""
    read -p "Proceed with commit? Type 'yes' to continue: " choice
    echo ""

    if [ "$choice" == "yes" ]; then
        print_warning "User confirmed. Proceeding..."
        return 0
    else
        print_error "Commit cancelled by user"
        return 1
    fi
}

# ==============================================================================
# GET STAGED FILES
# ==============================================================================

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    print_success "No files staged"
    exit 0
fi

print_header

# Count total files
TOTAL_FILES=$(echo "$STAGED_FILES" | wc -l)
echo "Scanning $TOTAL_FILES staged file(s)..."
echo ""

# Progress tracking
CURRENT_FILE=0

# ==============================================================================
# TIER 1: HARD BLOCK - Real Secrets (ALL AI Providers)
# ==============================================================================

echo "â”â”â” Checking for real API keys (all AI providers)..."

TIER1_BLOCKED=false

for file in $STAGED_FILES; do
    ((CURRENT_FILE++))

    if is_ignored "$file"; then
        echo "  [$CURRENT_FILE/$TOTAL_FILES] Skipped (ignored): $(basename "$file")"
        continue
    fi

    # Show progress
    echo "  [$CURRENT_FILE/$TOTAL_FILES] Scanning: $(basename "$file")"

    if file "$file" 2>/dev/null | grep -q "binary"; then
        continue
    fi

    if [ ! -f "$file" ]; then
        continue
    fi

    line_num=0
    while IFS= read -r line || [ -n "$line" ]; do
        ((++line_num))

        if has_bypass_comment "$line"; then
            continue
        fi

        # ============================================================
        # ANTHROPIC (Claude)
        # ============================================================

        # Real Anthropic API key: sk-ant-api03-{95 chars}
        if echo "$line" | grep -qE 'sk-ant-api03-[A-Za-z0-9_-]{95}'; then
            print_error "BLOCKED: Real Anthropic API key in $file:$line_num"
            echo "   Provider: Anthropic (Claude)"
            echo "   Fix: Use process.env.ANTHROPIC_API_KEY"
            TIER1_BLOCKED=true
        fi

        # ============================================================
        # OPENAI (GPT, ChatGPT, DALL-E)
        # ============================================================

        # Real OpenAI API key: sk-{48-51 chars}
        if echo "$line" | grep -qE 'sk-[a-zA-Z0-9]{48,51}' && ! echo "$line" | grep -qE 'sk-ant-'; then
            print_error "BLOCKED: Real OpenAI API key in $file:$line_num"
            echo "   Provider: OpenAI (GPT)"
            echo "   Fix: Use process.env.OPENAI_API_KEY"
            TIER1_BLOCKED=true
        fi

        # ============================================================
        # GOOGLE (Gemini, PaLM, Vertex AI)
        # ============================================================

        # Google API key: AIza{39 chars}
        if echo "$line" | grep -qE 'AIza[A-Za-z0-9_-]{35}'; then
            print_error "BLOCKED: Real Google AI API key in $file:$line_num"
            echo "   Provider: Google (Gemini, PaLM)"
            echo "   Fix: Use process.env.GOOGLE_API_KEY"
            TIER1_BLOCKED=true
        fi

        # ============================================================
        # HUGGING FACE
        # ============================================================

        # Hugging Face token: hf_{32+ chars}
        if echo "$line" | grep -qE 'hf_[A-Za-z0-9]{32,}'; then
            print_error "BLOCKED: Real Hugging Face token in $file:$line_num"
            echo "   Provider: Hugging Face"
            echo "   Fix: Use process.env.HUGGINGFACE_TOKEN"
            TIER1_BLOCKED=true
        fi

        # ============================================================
        # COHERE
        # ============================================================

        # Cohere API key: {40 alphanum after 'cohere'}
        if echo "$line" | grep -qiE 'cohere.*[A-Za-z0-9]{40}'; then
            print_error "BLOCKED: Potential Cohere API key in $file:$line_num"
            echo "   Provider: Cohere"
            echo "   Fix: Use process.env.COHERE_API_KEY"
            TIER1_BLOCKED=true
        fi

        # ============================================================
        # REPLICATE
        # ============================================================

        # Replicate token: r8_{40 chars}
        if echo "$line" | grep -qE 'r8_[A-Za-z0-9]{40}'; then
            print_error "BLOCKED: Real Replicate token in $file:$line_num"
            echo "   Provider: Replicate"
            echo "   Fix: Use process.env.REPLICATE_API_TOKEN"
            TIER1_BLOCKED=true
        fi

        # ============================================================
        # GITHUB (Copilot, Actions)
        # ============================================================

        # GitHub Personal Access Token: ghp_{36 chars}
        if echo "$line" | grep -qE 'ghp_[A-Za-z0-9]{36}'; then
            print_error "BLOCKED: Real GitHub token in $file:$line_num"
            echo "   Provider: GitHub"
            echo "   Fix: Use process.env.GITHUB_TOKEN"
            TIER1_BLOCKED=true
        fi

        # GitHub OAuth: gho_{36 chars}
        if echo "$line" | grep -qE 'gho_[A-Za-z0-9]{36}'; then
            print_error "BLOCKED: Real GitHub OAuth token in $file:$line_num"
            echo "   Provider: GitHub OAuth"
            TIER1_BLOCKED=true
        fi

        # ============================================================
        # AWS (Bedrock, SageMaker)
        # ============================================================

        # AWS Access Key: AKIA{16 chars}
        if echo "$line" | grep -qE 'AKIA[A-Z0-9]{16}'; then
            print_error "BLOCKED: Real AWS access key in $file:$line_num"
            echo "   Provider: AWS"
            echo "   Fix: Use process.env.AWS_ACCESS_KEY_ID"
            TIER1_BLOCKED=true
        fi

        # ============================================================
        # STRIPE
        # ============================================================

        # Stripe Secret Key: sk_live_{24+ chars}
        if echo "$line" | grep -qE 'sk_live_[A-Za-z0-9]{24,}'; then
            print_error "BLOCKED: Real Stripe secret key in $file:$line_num"
            echo "   Provider: Stripe"
            echo "   Fix: Use process.env.STRIPE_SECRET_KEY"
            TIER1_BLOCKED=true
        fi

        # ============================================================
        # AZURE OPENAI
        # ============================================================

        # Azure OpenAI key pattern (32 hex chars)
        if echo "$line" | grep -qiE 'azure.*[a-f0-9]{32}' && echo "$line" | grep -qiE 'openai|cognitive'; then
            print_error "BLOCKED: Potential Azure OpenAI key in $file:$line_num"
            echo "   Provider: Azure OpenAI"
            echo "   Fix: Use process.env.AZURE_OPENAI_KEY"
            TIER1_BLOCKED=true
        fi

        # ============================================================
        # PRIVATE KEYS
        # ============================================================

        if echo "$line" | grep -q "BEGIN PRIVATE KEY"; then
            print_error "BLOCKED: Private key detected in $file:$line_num"
            echo "   Type: Cryptographic private key"
            TIER1_BLOCKED=true
        fi

        if echo "$line" | grep -q "BEGIN RSA PRIVATE KEY"; then
            print_error "BLOCKED: RSA private key detected in $file:$line_num"
            echo "   Type: RSA private key"
            TIER1_BLOCKED=true
        fi

        # ============================================================
        # HIGH ENTROPY STRINGS (Generic Secret Detection)
        # ============================================================

        # Extract quoted strings longer than 20 chars
        for quoted_string in $(echo "$line" | grep -oE '["\x27][A-Za-z0-9+/=_-]{20,}["\x27]'); do
            # Remove quotes
            clean_string=$(echo "$quoted_string" | tr -d '"' | tr -d "'")

            # Skip known safe patterns
            if echo "$clean_string" | grep -qiE 'example|test|demo|placeholder|your.?key|xxx|sample|fake'; then
                continue
            fi

            # Calculate entropy
            entropy=$(calculate_entropy "$clean_string")

            # High entropy threshold (likely random secret)
            if (( $(echo "$entropy > 4.5" | bc -l 2>/dev/null || echo 0) )); then
                print_error "BLOCKED: High-entropy string (likely secret) in $file:$line_num"
                echo "   Entropy: $entropy (threshold: 4.5)"
                echo "   Pattern: Random string with ${#clean_string} chars"
                echo "   Fix: Move to environment variable"
                TIER1_BLOCKED=true
            fi
        done

    done < "$file"
done

# Check blocked file types
for file in $STAGED_FILES; do
    filename=$(basename "$file")

    # Real .env files
    if [[ "$filename" == ".env" ]] || \
       [[ "$filename" == ".env.local" ]] || \
       [[ "$filename" == ".env.production" ]] || \
       [[ "$filename" == ".env.development" ]]; then
        print_error "BLOCKED: Environment file detected: $file"
        echo "   Reason: Contains secrets"
        TIER1_BLOCKED=true
    fi

    # Private key files
    if [[ "$file" =~ \.(pem|key|p12|pfx)$ ]]; then
        print_error "BLOCKED: Private key file: $file"
        TIER1_BLOCKED=true
    fi

    # Credentials files
    if [[ "$filename" == "credentials.json" ]] || [[ "$filename" == "secrets.json" ]]; then
        print_error "BLOCKED: Credentials file: $file"
        TIER1_BLOCKED=true
    fi
done

if [ "$TIER1_BLOCKED" == "true" ]; then
    HARD_BLOCKED=true
    echo ""
    echo "  Summary: Secrets detected - commit blocked"
else
    echo ""
    echo "  Summary: No secrets detected in $TOTAL_FILES file(s)"
fi
echo ""

# ==============================================================================
# TIER 2: WARNING + CHOICE - Suspicious Patterns
# ==============================================================================

echo "â”â”â” Checking for suspicious patterns..."
CURRENT_FILE=0  # Reset counter for TIER 2

for file in $STAGED_FILES; do
    if is_ignored "$file"; then
        continue
    fi

    if file "$file" 2>/dev/null | grep -q "binary"; then
        continue
    fi

    if [ ! -f "$file" ]; then
        continue
    fi

    # Only check source files
    if [[ ! "$file" =~ \.(js|ts|jsx|tsx|py|go|rb|java|cs|php|sh|yml|yaml|json)$ ]]; then
        continue
    fi

    line_num=0
    while IFS= read -r line || [ -n "$line" ]; do
        ((++line_num))

        if has_bypass_comment "$line"; then
            continue
        fi

        # Skip comments
        if [[ "$line" =~ ^[[:space:]]*// ]] || \
           [[ "$line" =~ ^[[:space:]]*# ]] || \
           [[ "$line" =~ ^[[:space:]]*\* ]]; then
            continue
        fi

        # Generic API_KEY assignment
        if echo "$line" | grep -qiE '[^a-z_]API_?KEY["\x27]\s*:\s*["\x27][A-Za-z0-9_-]{16,}["\x27]' || \
           echo "$line" | grep -qiE '[^a-z_]API_?KEY\s*=\s*["\x27][A-Za-z0-9_-]{16,}["\x27]'; then

            if echo "$line" | grep -qiE 'your.?key|example|placeholder|xxx|test|demo|fake|sample'; then
                continue
            fi

            print_warning "Suspicious API key assignment in $file:$line_num"
            echo "   Pattern: API_KEY = \"...\""
            ((WARNINGS_COUNT++))

            if ! ask_user_confirmation "Possible hardcoded API key detected"; then
                HARD_BLOCKED=true
                break
            fi
        fi

        # Bearer tokens
        if echo "$line" | grep -qE 'Bearer [A-Za-z0-9_-]{20,}'; then
            if echo "$line" | grep -qiE 'example|placeholder|xxx|your.?token'; then
                continue
            fi

            print_warning "Suspicious Bearer token in $file:$line_num"
            ((WARNINGS_COUNT++))

            if ! ask_user_confirmation "Possible hardcoded Bearer token detected"; then
                HARD_BLOCKED=true
                break
            fi
        fi

        # Database connection strings
        if echo "$line" | grep -qE '(postgres|mysql|mongodb)://[^:]+:[^@]{8,}@'; then
            if echo "$line" | grep -qiE 'example|localhost|127\.0\.0\.1|password|user'; then
                continue
            fi

            print_warning "Database connection string in $file:$line_num"
            ((WARNINGS_COUNT++))

            if ! ask_user_confirmation "Possible database credentials in connection string"; then
                HARD_BLOCKED=true
                break
            fi
        fi

    done < "$file"

    if [ "$HARD_BLOCKED" == "true" ]; then
        break
    fi
done

# ==============================================================================
# LANG-CRITICAL & RUSSIAN TRACKERS (unchanged)
# ==============================================================================

echo "â”â”â” Checking for LANG-CRITICAL violations..."

LANG_WHITELIST=(
    "scripts/pre-commit"
    "scripts/pre-commit.js"
    "scripts/pre-commit.ps1"
    "scripts/ai-protection.sh"
    "scripts/ai-protection.js"
    "scripts/ai-protection.ps1"
    ".git/hooks/pre-commit"
    "scripts/seo-check.sh"
    ".ai/forbidden-trackers.json"
    ".ai/security-policy.json"
    ".ai/ai-protection-policy.json"
    ".ai/prompt-injection-patterns.json"
    ".ai/pii-patterns.json"
    ".ai/THREAT_MODEL.md"
    ".ai/DISCLAIMERS.md"
    ".ai/contexts/"
    "RULES_PRODUCT.md"
    "RULES_CORE.md"
    "README.md"
    "README.old.md"
    "ROADMAP_AI_PROTECTION.md"
)

LANG_PATTERNS=(
    '\.ru[^a-z]'
    'ru-RU'
    'ru_RU'
    '"ru"'
)

for file in $STAGED_FILES; do
    if file "$file" 2>/dev/null | grep -q "binary"; then
        continue
    fi

    skip=false
    for whitelist_file in "${LANG_WHITELIST[@]}"; do
        if [[ "$file" == *"$whitelist_file"* ]]; then
            skip=true
            break
        fi
    done

    if [ "$skip" == "true" ] || [ ! -f "$file" ]; then
        continue
    fi

    for pattern in "${LANG_PATTERNS[@]}"; do
        if grep -qE "$pattern" "$file" 2>/dev/null; then
            line_number=$(grep -nE "$pattern" "$file" | head -n 1 | cut -d: -f1)
            print_error "LANG-CRITICAL violation in: $file:$line_number"
            echo "   Pattern: $pattern"
            VIOLATIONS_FOUND=true
        fi
    done
done

echo "â”â”â” Checking for russian tracking services..."

TRACKER_WHITELIST=(
    ".ai/forbidden-trackers.json"
    ".ai/security-policy.json"
    ".ai/ai-protection-policy.json"
    ".ai/pii-patterns.json"
    ".ai/THREAT_MODEL.md"
    "scripts/seo-check.sh"
    "scripts/pre-commit"
    "scripts/pre-commit.js"
    "scripts/pre-commit.ps1"
    "RULES_PRODUCT.md"
    "README.md"
    "README.old.md"
)

TRACKER_PATTERNS=(
    "metrika\\.yandex"
    "mc\\.yandex"
    "top\\.mail\\.ru"
    "vk\\.com/js/api"
    "vk\\.com/pixel"
    "VK\\.Retargeting"
    "yookassa"
    "kassa\\.yandex"
    "api-maps\\.yandex"
    "2gis"
    "wildberries"
    "ozon\\.ru"
)

for file in $STAGED_FILES; do
    if file "$file" 2>/dev/null | grep -q "binary"; then
        continue
    fi

    skip=false
    for whitelist_file in "${TRACKER_WHITELIST[@]}"; do
        if [[ "$file" == *"$whitelist_file"* ]]; then
            skip=true
            break
        fi
    done

    if [ "$skip" == "true" ] || [ ! -f "$file" ]; then
        continue
    fi

    for pattern in "${TRACKER_PATTERNS[@]}"; do
        if grep -qiE "$pattern" "$file" 2>/dev/null; then
            line_number=$(grep -inE "$pattern" "$file" | head -n 1 | cut -d: -f1)
            print_error "RUSSIAN TRACKER detected in: $file:$line_number"
            echo "   Pattern: $pattern"
            TRACKERS_FOUND=true
        fi
    done
done

# ==============================================================================
# AI PROTECTION (v9.0+)
# ==============================================================================

echo "â”â”â” AI Protection: Checking for threats..."

AI_PROTECTION_FAILED=false

# Check if AI protection is enabled
if [ -f ".ai/ai-protection-policy.json" ]; then
    # Check if AI protection script exists
    if [ -f "scripts/ai-protection.sh" ]; then
        # Run AI protection checks
        if bash scripts/ai-protection.sh; then
            echo -e "${GREEN}âœ“${NC} AI Protection passed"
        else
            AI_PROTECTION_FAILED=true
            echo -e "${RED}âœ—${NC} AI Protection detected threats"
        fi
    else
        # Script missing - warn but don't block (backward compatibility)
        echo -e "${YELLOW}âš ${NC}  AI Protection script not found (scripts/ai-protection.sh)"
        echo "   Run installer to add AI Protection: npx @shamavision/ai-workflow-rules@9.0.0 init"
    fi
else
    # Policy file missing - skip silently (backward compatibility)
    : # No-op
fi

# ==============================================================================
# FINAL VERDICT
# ==============================================================================

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

if [ "$VIOLATIONS_FOUND" == "true" ]; then
    echo -e "${YELLOW}âš ï¸  LANG-CRITICAL WARNINGS DETECTED${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "Russian content patterns detected."
    echo -e "${YELLOW}Commit will PROCEED (this is a warning)${NC}"
    echo ""
fi

if [ "$HARD_BLOCKED" == "true" ]; then
    echo -e "${RED}âŒ COMMIT BLOCKED${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ğŸš¨ Your commit contains sensitive data or was cancelled."
    echo ""
    if [ "$IS_CI" == "true" ]; then
        echo "Running in CI/CD: Set SECURITY_HOOK_MODE=permissive to bypass tier 2"
    fi
    echo ""
    log_to_audit_trail "HARD_BLOCK" "Secrets detected or user cancellation"
    exit 1
fi

if [ "$TRACKERS_FOUND" == "true" ]; then
    echo -e "${RED}âŒ COMMIT BLOCKED - RUSSIAN TRACKERS${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    log_to_audit_trail "RUSSIAN_TRACKERS" "Trackers detected"
    exit 1
fi

if [ "$AI_PROTECTION_FAILED" == "true" ]; then
    echo -e "${RED}âŒ COMMIT BLOCKED - AI PROTECTION${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ğŸ¤– AI Protection detected threats:"
    echo "   - Prompt injection attempts"
    echo "   - PII in AI logs"
    echo "   - .ai/ directory violations"
    echo ""
    echo "See details above for specific issues."
    echo ""
    log_to_audit_trail "AI_PROTECTION" "AI threats detected"
    exit 1
fi

if [ "$HARD_BLOCKED" == "false" ] && [ "$TRACKERS_FOUND" == "false" ] && [ "$AI_PROTECTION_FAILED" == "false" ]; then
    echo -e "${GREEN}âœ… SECURITY SCAN PASSED${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    if [ $WARNINGS_COUNT -gt 0 ]; then
        print_success "No critical issues (user confirmed $WARNINGS_COUNT warning(s))"
    else
        print_success "No secrets or trackers detected"
    fi

    echo ""
fi

# ==============================================================================
# CODE QUALITY CHECK (v9.1 - Non-blocking warnings)
# ==============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SCRIPT_DIR/pre-commit-lint.sh" ]; then
    bash "$SCRIPT_DIR/pre-commit-lint.sh" || true  # Never fail commit
fi

echo "Proceeding with commit..."
echo ""
exit 0

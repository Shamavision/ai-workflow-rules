#!/bin/bash
# ==============================================================================
# PRE-COMMIT HOOK - INTELLIGENT SECRETS SCANNER
# AI Workflow Rules Framework v8.2
# ==============================================================================
#
# PHILOSOPHY: Silent Guardian Architecture
#   Protect without blocking productivity
#   Trust informed decisions
#
# SECURITY APPROACH: 3-Tier Protection
#   Tier 1: HARD BLOCK - Real secrets (100% confidence)
#   Tier 2: WARNING + CHOICE - Suspicious patterns (let user decide)
#   Tier 3: SILENT - Legitimate cases (context-aware)
#
# WHAT IT CHECKS:
#   1. Real API keys (Anthropic, OpenAI, GitHub, AWS, Stripe)
#   2. Private keys and certificates
#   3. High-entropy strings (likely secrets)
#   4. Hardcoded credentials (with bypass option)
#   5. LANG-CRITICAL violations (russian content) - WARNING
#   6. Russian tracking services - BLOCK
#
# BYPASS MECHANISMS:
#   - Comment: // secure-ignore or # secure-ignore
#   - File: .securityignore (gitignore syntax)
#   - Interactive: Type 'yes' for tier 2 warnings
#   - Emergency: git commit --no-verify (disables ALL checks)
#
# CONFIGURATION:
#   - .ai/security-policy.json (optional, for custom rules)
#   - .securityignore (optional, for known false positives)
#
# ==============================================================================

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Flags
HARD_BLOCKED=false
VIOLATIONS_FOUND=false
TRACKERS_FOUND=false
WARNINGS_COUNT=0

# Config
SECURITY_POLICY=".ai/security-policy.json"
SECURITY_IGNORE=".securityignore"
AUDIT_TRAIL=".ai/audit-trail.log"

# ==============================================================================
# FUNCTIONS
# ==============================================================================

print_header() {
    echo -e "${BLUE}ğŸ”’ Pre-Commit Security Scan${NC}"
    echo ""
}

print_error() {
    echo -e "${RED}âŒ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}âš ï¸  $1${NC}"
}

print_success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

print_info() {
    echo -e "${CYAN}â„¹ï¸  $1${NC}"
}

# Calculate Shannon entropy (detect random strings likely to be secrets)
calculate_entropy() {
    local string="$1"
    local length=${#string}

    if [ $length -lt 16 ]; then
        echo "0"
        return
    fi

    # Count character frequencies
    declare -A freq
    for (( i=0; i<$length; i++ )); do
        char="${string:$i:1}"
        ((freq[$char]++))
    done

    # Calculate Shannon entropy
    local entropy=0
    for count in "${freq[@]}"; do
        local p=$(echo "scale=4; $count / $length" | bc)
        local log_p=$(echo "scale=4; l($p) / l(2)" | bc -l)
        entropy=$(echo "scale=4; $entropy - ($p * $log_p)" | bc)
    done

    echo "$entropy"
}

# Check if file should be ignored
is_ignored() {
    local file="$1"
    local filename=$(basename "$file")

    # Built-in whitelist (always allowed)
    local BUILT_IN_IGNORE=(
        ".env.example"
        ".env.sample"
        ".env.template"
        "scripts/pre-commit"
        ".git/hooks/pre-commit"
        "scripts/seo-check.sh"
        ".ai/security-policy.json"
        ".ai/forbidden-trackers.json"
        ".ai/token-limits.json"
        "RULES_PRODUCT.md"
        "RULES_CORE.md"
        "node_modules/"
        "dist/"
        "build/"
        ".next/"
        "examples/"
        "tests/fixtures/"
        "__tests__/mocks/"
    )

    for pattern in "${BUILT_IN_IGNORE[@]}"; do
        if [[ "$file" == *"$pattern"* ]]; then
            return 0  # ignored
        fi
    done

    # Check .securityignore file
    if [ -f "$SECURITY_IGNORE" ]; then
        while IFS= read -r pattern || [ -n "$pattern" ]; do
            # Skip comments and empty lines
            [[ "$pattern" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$pattern" ]] && continue

            # Simple glob matching
            if [[ "$file" == $pattern ]]; then
                return 0  # ignored
            fi
        done < "$SECURITY_IGNORE"
    fi

    return 1  # not ignored
}

# Check if line has bypass comment
has_bypass_comment() {
    local line="$1"

    if [[ "$line" == *"secure-ignore"* ]] || \
       [[ "$line" == *"security:ignore"* ]] || \
       [[ "$line" == *"nosecret"* ]]; then
        return 0  # has bypass
    fi

    return 1  # no bypass
}

# Log security events (audit trail for legal protection)
log_to_audit_trail() {
    local event_type="$1"
    local details="$2"

    mkdir -p .ai

    cat >> "$AUDIT_TRAIL" << EOF
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
[$(date '+%Y-%m-%d %H:%M:%S %Z')] COMMIT BLOCKED
Event: $event_type
Details: $details
Framework: ai-workflow-rules v8.2
User: $(git config user.name) <$(git config user.email)>
Branch: $(git branch --show-current)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

EOF
}

# Interactive prompt for tier 2 warnings
ask_user_confirmation() {
    local message="$1"

    echo ""
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${YELLOW}SECURITY WARNING${NC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo "$message"
    echo ""
    echo "How to fix:"
    echo "  1. Use environment variables: process.env.API_KEY"
    echo "  2. Move to .env file (gitignored)"
    echo "  3. If false positive: add comment // secure-ignore"
    echo "  4. Skip this check: git commit --no-verify"
    echo ""
    read -p "Proceed with commit? Type 'yes' to continue: " choice
    echo ""

    if [ "$choice" == "yes" ]; then
        print_warning "User confirmed. Proceeding..."
        return 0
    else
        print_error "Commit cancelled by user"
        return 1
    fi
}

# ==============================================================================
# GET STAGED FILES
# ==============================================================================

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    print_success "No files staged"
    exit 0
fi

print_header
echo "Scanning $(echo "$STAGED_FILES" | wc -l) staged file(s)..."
echo ""

# ==============================================================================
# TIER 1: HARD BLOCK - Real Secrets (100% confidence)
# ==============================================================================

echo "â”â”â” Checking for real API keys and secrets..."

TIER1_BLOCKED=false

for file in $STAGED_FILES; do
    # Skip if file should be ignored
    if is_ignored "$file"; then
        continue
    fi

    # Skip binary files
    if file "$file" 2>/dev/null | grep -q "binary"; then
        continue
    fi

    # Skip if file doesn't exist (deleted)
    if [ ! -f "$file" ]; then
        continue
    fi

    # Read file line by line
    line_num=0
    while IFS= read -r line || [ -n "$line" ]; do
        ((line_num++))

        # Skip if line has bypass comment
        if has_bypass_comment "$line"; then
            continue
        fi

        # Tier 1 Patterns: Real API Keys (exact formats)

        # Anthropic API key (real format: sk-ant-api03-{95 chars})
        if echo "$line" | grep -qE 'sk-ant-api03-[A-Za-z0-9_-]{95}'; then
            print_error "BLOCKED: Real Anthropic API key in $file:$line_num"
            echo "   Pattern: sk-ant-api03-***"
            echo "   This is a REAL API key and cannot be committed"
            echo "   Fix: Use process.env.ANTHROPIC_API_KEY"
            TIER1_BLOCKED=true
        fi

        # OpenAI API key (real format: sk-{48+ chars})
        if echo "$line" | grep -qE 'sk-[a-zA-Z0-9]{48,}'; then
            print_error "BLOCKED: Real OpenAI API key in $file:$line_num"
            echo "   Pattern: sk-***"
            echo "   This is a REAL API key and cannot be committed"
            echo "   Fix: Use process.env.OPENAI_API_KEY"
            TIER1_BLOCKED=true
        fi

        # GitHub Personal Access Token (real format: ghp_{36 chars})
        if echo "$line" | grep -qE 'ghp_[A-Za-z0-9]{36}'; then
            print_error "BLOCKED: Real GitHub token in $file:$line_num"
            echo "   Pattern: ghp_***"
            echo "   This is a REAL GitHub token and cannot be committed"
            echo "   Fix: Use process.env.GITHUB_TOKEN"
            TIER1_BLOCKED=true
        fi

        # GitHub OAuth token (gho_)
        if echo "$line" | grep -qE 'gho_[A-Za-z0-9]{36}'; then
            print_error "BLOCKED: Real GitHub OAuth token in $file:$line_num"
            echo "   Pattern: gho_***"
            TIER1_BLOCKED=true
        fi

        # AWS Access Key (real format: AKIA{16 chars})
        if echo "$line" | grep -qE 'AKIA[A-Z0-9]{16}'; then
            print_error "BLOCKED: Real AWS access key in $file:$line_num"
            echo "   Pattern: AKIA***"
            echo "   This is a REAL AWS credential and cannot be committed"
            echo "   Fix: Use process.env.AWS_ACCESS_KEY_ID"
            TIER1_BLOCKED=true
        fi

        # Stripe Secret Key (real format: sk_live_{24+ chars})
        if echo "$line" | grep -qE 'sk_live_[A-Za-z0-9]{24,}'; then
            print_error "BLOCKED: Real Stripe secret key in $file:$line_num"
            echo "   Pattern: sk_live_***"
            echo "   This is a REAL Stripe secret key and cannot be committed"
            echo "   Fix: Use process.env.STRIPE_SECRET_KEY"
            TIER1_BLOCKED=true
        fi

        # Private keys (PEM format)
        if echo "$line" | grep -q "BEGIN PRIVATE KEY"; then
            print_error "BLOCKED: Private key detected in $file:$line_num"
            echo "   This is a REAL private key and cannot be committed"
            echo "   Fix: Remove from code, store securely"
            TIER1_BLOCKED=true
        fi

        if echo "$line" | grep -q "BEGIN RSA PRIVATE KEY"; then
            print_error "BLOCKED: RSA private key detected in $file:$line_num"
            TIER1_BLOCKED=true
        fi

    done < "$file"
done

# Check for blocked file types
for file in $STAGED_FILES; do
    filename=$(basename "$file")

    # Block real .env files (not .env.example)
    if [[ "$filename" == ".env" ]] || \
       [[ "$filename" == ".env.local" ]] || \
       [[ "$filename" == ".env.production" ]] || \
       [[ "$filename" == ".env.development" ]]; then
        print_error "BLOCKED: Environment file detected: $file"
        echo "   Reason: Contains secrets"
        echo "   Fix: Unstage (git reset HEAD $file)"
        TIER1_BLOCKED=true
    fi

    # Block private key files
    if [[ "$file" =~ \.(pem|key|p12|pfx)$ ]]; then
        print_error "BLOCKED: Private key file: $file"
        echo "   Reason: Cryptographic keys must not be committed"
        TIER1_BLOCKED=true
    fi

    # Block credentials files
    if [[ "$filename" == "credentials.json" ]] || \
       [[ "$filename" == "secrets.json" ]]; then
        print_error "BLOCKED: Credentials file: $file"
        TIER1_BLOCKED=true
    fi
done

if [ "$TIER1_BLOCKED" == "true" ]; then
    HARD_BLOCKED=true
fi

# ==============================================================================
# TIER 2: WARNING + CHOICE - Suspicious Patterns
# ==============================================================================

echo "â”â”â” Checking for suspicious patterns..."

for file in $STAGED_FILES; do
    # Skip if ignored
    if is_ignored "$file"; then
        continue
    fi

    # Skip binary
    if file "$file" 2>/dev/null | grep -q "binary"; then
        continue
    fi

    # Skip if doesn't exist
    if [ ! -f "$file" ]; then
        continue
    fi

    # Only check source files for tier 2
    if [[ ! "$file" =~ \.(js|ts|jsx|tsx|py|go|rb|java|cs|php|sh)$ ]]; then
        continue
    fi

    line_num=0
    while IFS= read -r line || [ -n "$line" ]; do
        ((line_num++))

        # Skip if has bypass comment
        if has_bypass_comment "$line"; then
            continue
        fi

        # Skip comments (likely examples)
        if [[ "$line" =~ ^[[:space:]]*// ]] || \
           [[ "$line" =~ ^[[:space:]]*# ]] || \
           [[ "$line" =~ ^[[:space:]]*\* ]]; then
            continue
        fi

        # Tier 2 Patterns: Generic secrets (need user confirmation)

        # Generic API_KEY assignment with quotes
        if echo "$line" | grep -qiE '[^a-z_]API_?KEY["\x27]\s*:\s*["\x27][A-Za-z0-9_-]{16,}["\x27]' || \
           echo "$line" | grep -qiE '[^a-z_]API_?KEY\s*=\s*["\x27][A-Za-z0-9_-]{16,}["\x27]'; then

            # Exclude obvious placeholders
            if echo "$line" | grep -qiE 'your.?key|example|placeholder|xxx|test|demo|fake|sample'; then
                continue
            fi

            print_warning "Suspicious API key assignment in $file:$line_num"
            echo "   Pattern: API_KEY = \"...\""
            echo "   Context: $(echo "$line" | sed 's/^[[:space:]]*//' | cut -c1-60)..."
            ((WARNINGS_COUNT++))

            if ! ask_user_confirmation "Possible hardcoded API key detected"; then
                HARD_BLOCKED=true
                break
            fi
        fi

        # Bearer tokens
        if echo "$line" | grep -qE 'Bearer [A-Za-z0-9_-]{20,}'; then
            if echo "$line" | grep -qiE 'example|placeholder|xxx|your.?token'; then
                continue
            fi

            print_warning "Suspicious Bearer token in $file:$line_num"
            ((WARNINGS_COUNT++))

            if ! ask_user_confirmation "Possible hardcoded Bearer token detected"; then
                HARD_BLOCKED=true
                break
            fi
        fi

        # Database connection strings with credentials
        if echo "$line" | grep -qE '(postgres|mysql|mongodb)://[^:]+:[^@]{8,}@'; then
            if echo "$line" | grep -qiE 'example|localhost|127\.0\.0\.1|password|user'; then
                continue
            fi

            print_warning "Database connection string in $file:$line_num"
            ((WARNINGS_COUNT++))

            if ! ask_user_confirmation "Possible database credentials in connection string"; then
                HARD_BLOCKED=true
                break
            fi
        fi

    done < "$file"

    # Break outer loop if user cancelled
    if [ "$HARD_BLOCKED" == "true" ]; then
        break
    fi
done

# ==============================================================================
# TIER 3: SILENT - Legitimate Cases (context-aware)
# ==============================================================================

# Tier 3 is handled by is_ignored() function
# These files are silently allowed:
# - .env.example (placeholders)
# - Documentation (*.md)
# - Test fixtures (tests/fixtures/)
# - Comments (detected inline)

# ==============================================================================
# CHECK: LANG-CRITICAL VIOLATIONS (WARNING only)
# ==============================================================================

echo "â”â”â” Checking for LANG-CRITICAL violations..."

LANG_WHITELIST=(
    "scripts/pre-commit"
    ".git/hooks/pre-commit"
    "scripts/seo-check.sh"
    ".ai/forbidden-trackers.json"
    ".ai/contexts/"
    "RULES_PRODUCT.md"
    "RULES_CORE.md"
    "README.md"
)

LANG_PATTERNS=(
    '\.ru[^a-z]'
    'ru-RU'
    'ru_RU'
    '"ru"'
)

for file in $STAGED_FILES; do
    # Skip binary
    if file "$file" 2>/dev/null | grep -q "binary"; then
        continue
    fi

    # Skip whitelisted
    skip=false
    for whitelist_file in "${LANG_WHITELIST[@]}"; do
        if [[ "$file" == *"$whitelist_file"* ]]; then
            skip=true
            break
        fi
    done

    if [ "$skip" == "true" ]; then
        continue
    fi

    # Skip if doesn't exist
    if [ ! -f "$file" ]; then
        continue
    fi

    for pattern in "${LANG_PATTERNS[@]}"; do
        if grep -qE "$pattern" "$file" 2>/dev/null; then
            line_number=$(grep -nE "$pattern" "$file" | head -n 1 | cut -d: -f1)

            print_error "LANG-CRITICAL violation in: $file:$line_number"
            echo "   Pattern: $pattern (Russian content detected)"
            echo "   Fix: Remove russian content (see RULES_PRODUCT.md Section 3)"

            VIOLATIONS_FOUND=true
        fi
    done
done

# ==============================================================================
# CHECK: RUSSIAN TRACKING SERVICES (BLOCK)
# ==============================================================================

echo "â”â”â” Checking for russian tracking services..."

TRACKER_WHITELIST=(
    ".ai/forbidden-trackers.json"
    "scripts/seo-check.sh"
    "scripts/pre-commit"
    ".git/hooks/pre-commit"
    "RULES_PRODUCT.md"
    "README.md"
)

TRACKER_PATTERNS=(
    "metrika\\.yandex"
    "mc\\.yandex"
    "top\\.mail\\.ru"
    "vk\\.com/js/api"
    "vk\\.com/pixel"
    "VK\\.Retargeting"
    "yookassa"
    "kassa\\.yandex"
    "api-maps\\.yandex"
    "2gis"
    "wildberries"
    "ozon\\.ru"
)

for file in $STAGED_FILES; do
    # Skip binary
    if file "$file" 2>/dev/null | grep -q "binary"; then
        continue
    fi

    # Skip whitelisted
    skip=false
    for whitelist_file in "${TRACKER_WHITELIST[@]}"; do
        if [[ "$file" == *"$whitelist_file"* ]]; then
            skip=true
            break
        fi
    done

    if [ "$skip" == "true" ]; then
        continue
    fi

    # Skip if doesn't exist
    if [ ! -f "$file" ]; then
        continue
    fi

    for pattern in "${TRACKER_PATTERNS[@]}"; do
        if grep -qiE "$pattern" "$file" 2>/dev/null; then
            line_number=$(grep -inE "$pattern" "$file" | head -n 1 | cut -d: -f1)

            print_error "RUSSIAN TRACKER detected in: $file:$line_number"
            echo "   Pattern: $pattern"
            echo "   Threat: Data sent to russian servers"
            echo ""
            echo "   Safe alternatives:"
            echo "     Analytics: Google Analytics, Plausible"
            echo "     Payments: Stripe, PayPal, WayForPay (UA)"
            echo ""

            TRACKERS_FOUND=true
        fi
    done
done

# ==============================================================================
# FINAL VERDICT
# ==============================================================================

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# LANG-CRITICAL = WARNING (doesn't block)
if [ "$VIOLATIONS_FOUND" == "true" ]; then
    echo -e "${YELLOW}âš ï¸  LANG-CRITICAL WARNINGS DETECTED${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "Russian content patterns detected."
    echo ""
    echo "Review findings above:"
    echo "  â€¢ If legitimate (examples, patterns): proceed"
    echo "  â€¢ If actual violation: fix before commit"
    echo ""
    echo -e "${YELLOW}Commit will PROCEED (this is a warning)${NC}"
    echo ""
fi

# TIER 1 HARD BLOCK or USER CANCELLED
if [ "$HARD_BLOCKED" == "true" ]; then
    echo -e "${RED}âŒ COMMIT BLOCKED${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ğŸš¨ Your commit contains sensitive data or was cancelled."
    echo ""
    echo "To fix:"
    echo "  1. Remove secrets from files"
    echo "  2. Use environment variables (process.env.VAR)"
    echo "  3. Add to .gitignore if needed"
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    log_to_audit_trail "HARD_BLOCK" "Secrets or user cancellation"

    exit 1
fi

# RUSSIAN TRACKERS = BLOCK
if [ "$TRACKERS_FOUND" == "true" ]; then
    echo -e "${RED}âŒ COMMIT BLOCKED - RUSSIAN TRACKERS${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ğŸš¨ Russian tracking services detected."
    echo ""
    echo "Security threat:"
    echo "  â€¢ User data sent to russian state servers"
    echo "  â€¢ GDPR violations"
    echo "  â€¢ Legal liability"
    echo ""
    echo "To fix:"
    echo "  1. Remove russian trackers (see errors above)"
    echo "  2. Replace with safe alternatives"
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    log_to_audit_trail "RUSSIAN_TRACKERS" "Staging files contain trackers"

    exit 1
fi

# ALL CLEAR
if [ "$HARD_BLOCKED" == "false" ] && [ "$TRACKERS_FOUND" == "false" ]; then
    echo -e "${GREEN}âœ… SECURITY SCAN PASSED${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    if [ $WARNINGS_COUNT -gt 0 ]; then
        print_success "No critical issues (user confirmed $WARNINGS_COUNT warning(s))"
    else
        print_success "No secrets or trackers detected"
    fi

    echo ""
fi

echo "Proceeding with commit..."
echo ""
exit 0

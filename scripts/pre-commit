#!/bin/bash
# ==============================================================================
# PRE-COMMIT HOOK - UNIVERSAL INTELLIGENT SECRETS SCANNER + AI PROTECTION
# AI Workflow Rules Framework v9.1.1
# ==============================================================================
#
# PHILOSOPHY: Silent Guardian Architecture
#   Protect without blocking productivity
#   Trust informed decisions
#   Universal compatibility (all IDEs, all AI providers, all platforms)
#
# SECURITY APPROACH: 3-Tier Protection + AI Protection
#   Tier 1: HARD BLOCK - Real secrets (100% confidence)
#   Tier 2: WARNING + CHOICE - Suspicious patterns (let user decide)
#   Tier 3: SILENT - Legitimate cases (context-aware)
#   AI Protection: Prompt injection + PII detection + Fail-closed hooks
#
# PERFORMANCE (Task 3 - Optimized):
#   Target: <10 seconds per commit
#   Method: File-level grep (no line loops), parallel checks, no Python entropy
#
# BYPASS MECHANISMS:
#   - Comment: // secure-ignore or # secure-ignore
#   - File: .securityignore (gitignore syntax)
#   - Interactive: Type 'yes' for tier 2 warnings (auto-skip in CI/CD)
#   - Emergency: git commit --no-verify (disables ALL checks)
#   - Env var: SECURITY_HOOK_MODE=permissive (for CI/CD)
#
# ==============================================================================

set -e

# Colors (disabled in non-TTY environments like CI/CD)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    CYAN=''
    NC=''
fi

# Detect environment
IS_INTERACTIVE=false
IS_CI=false

if [ -t 0 ] && [ -t 1 ]; then
    IS_INTERACTIVE=true
fi

if [ "$CI" == "true" ] || \
   [ "$GITHUB_ACTIONS" == "true" ] || \
   [ "$GITLAB_CI" == "true" ] || \
   [ "$JENKINS_HOME" != "" ] || \
   [ "$CIRCLECI" == "true" ] || \
   [ "$TRAVIS" == "true" ]; then
    IS_CI=true
    IS_INTERACTIVE=false
fi

HOOK_MODE="${SECURITY_HOOK_MODE:-balanced}"  # strict | balanced | permissive

HARD_BLOCKED=false
VIOLATIONS_FOUND=false
TRACKERS_FOUND=false
WARNINGS_COUNT=0

SECURITY_IGNORE=".securityignore"
AUDIT_TRAIL=".ai/audit-trail.log"

# ==============================================================================
# FUNCTIONS
# ==============================================================================

print_header() {
    echo -e "${BLUE}ğŸ”’ Pre-Commit Security Scan${NC}"
    [ "$IS_CI" == "true" ] && echo -e "${CYAN}   Environment: CI/CD (non-interactive mode)${NC}"
    echo ""
}

print_error()   { echo -e "${RED}âŒ $1${NC}"; }
print_warning() { echo -e "${YELLOW}âš ï¸  $1${NC}"; }
print_success() { echo -e "${GREEN}âœ… $1${NC}"; }
print_info()    { echo -e "${CYAN}â„¹ï¸  $1${NC}"; }

# Check if file should be ignored
is_ignored() {
    local file="$1"

    local BUILT_IN_IGNORE=(
        ".env.example"
        ".env.sample"
        ".env.template"
        "scripts/pre-commit"
        "scripts/pre-commit.js"
        "scripts/pre-commit.ps1"
        "scripts/install.sh"
        "scripts/install.ps1"
        "scripts/sync-rules.sh"
        "bin/cli.js"
        ".git/hooks/pre-commit"
        "scripts/seo-check.sh"
        "scripts/token-status.sh"
        ".ai/security-policy.json"
        ".ai/ai-protection-policy.json"
        ".ai/prompt-injection-patterns.json"
        ".ai/pii-patterns.json"
        ".ai/forbidden-trackers.json"
        ".ai/token-limits.json"
        "node_modules/"
        "npm-templates/"
        "dist/"
        "build/"
        ".next/"
        "examples/"
        "tests/fixtures/"
        "__tests__/mocks/"
    )

    for pattern in "${BUILT_IN_IGNORE[@]}"; do
        [[ "$file" == *"$pattern"* ]] && return 0
    done

    if [ -f "$SECURITY_IGNORE" ]; then
        while IFS= read -r pattern || [ -n "$pattern" ]; do
            [[ "$pattern" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$pattern" ]] && continue
            [[ "$file" == $pattern ]] && return 0
        done < "$SECURITY_IGNORE"
    fi

    return 1
}

# Check if line has bypass comment
has_bypass_comment() {
    local line="$1"
    [[ "$line" == *"secure-ignore"* ]] || \
    [[ "$line" == *"security:ignore"* ]] || \
    [[ "$line" == *"nosecret"* ]]
}

# Log security events
log_to_audit_trail() {
    local event_type="$1"
    local details="$2"
    mkdir -p .ai
    cat >> "$AUDIT_TRAIL" << EOF
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
[$(date '+%Y-%m-%d %H:%M:%S %Z')] COMMIT BLOCKED
Event: $event_type
Details: $details
Framework: ai-workflow-rules v9.1.1
User: $(git config user.name) <$(git config user.email)>
Branch: $(git branch --show-current)
Environment: $([ "$IS_CI" == "true" ] && echo "CI/CD" || echo "Interactive")
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

EOF
}

# Interactive prompt (auto-skip in CI/CD)
ask_user_confirmation() {
    local message="$1"

    if [ "$IS_INTERACTIVE" == "false" ]; then
        print_warning "Non-interactive mode: Auto-blocking suspicious pattern"
        return 1
    fi

    if [ "$HOOK_MODE" == "permissive" ]; then
        print_warning "Permissive mode: Auto-allowing"
        return 0
    fi

    echo ""
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${YELLOW}SECURITY WARNING${NC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo "$message"
    echo ""
    echo "How to fix:"
    echo "  1. Use environment variables: process.env.API_KEY"
    echo "  2. Move to .env file (gitignored)"
    echo "  3. If false positive: add comment // secure-ignore"
    echo "  4. Skip this check: git commit --no-verify"
    echo ""
    read -p "Proceed with commit? Type 'yes' to continue: " choice
    echo ""

    if [ "$choice" == "yes" ]; then
        print_warning "User confirmed. Proceeding..."
        return 0
    else
        print_error "Commit cancelled by user"
        return 1
    fi
}

# Check a single secret pattern in a file (file-level grep, not line-level)
# Usage: check_secret_pattern "pattern" "file" "label" "fix_var"
# Returns: 0 if found (blocked), 1 if not found
check_secret_pattern() {
    local pattern="$1"
    local file="$2"
    local label="$3"
    local fix_var="$4"

    if grep -qE "$pattern" "$file" 2>/dev/null; then
        local ln
        ln=$(grep -nmE "$pattern" "$file" 2>/dev/null | head -1 | cut -d: -f1)
        print_error "BLOCKED: $label in $file:${ln:-?}"
        [ -n "$fix_var" ] && echo "   Fix: Use process.env.${fix_var}"
        return 0
    fi
    return 1
}

# ==============================================================================
# GET STAGED FILES + PRE-FILTER (binary, ignored)
# ==============================================================================

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    print_success "No files staged"
    exit 0
fi

print_header

# Pre-filter files: skip ignored + binary files once (avoid repeated checks)
SCAN_FILES=()
SOURCE_FILES=()  # Only .js/.ts/.json/.sh/.yml etc (for Tier 2)

TOTAL_STAGED=$(echo "$STAGED_FILES" | wc -l | tr -d ' ')

while IFS= read -r file; do
    # Check ignored list
    if is_ignored "$file"; then
        continue
    fi

    # Skip non-existent files
    [ ! -f "$file" ] && continue

    # Skip binary files
    if file "$file" 2>/dev/null | grep -q "binary"; then
        continue
    fi

    SCAN_FILES+=("$file")

    # Source files for Tier 2 (suspicious pattern checks)
    if [[ "$file" =~ \.(js|ts|jsx|tsx|py|go|rb|java|cs|php|sh|yml|yaml|json)$ ]]; then
        SOURCE_FILES+=("$file")
    fi

done <<< "$STAGED_FILES"

TOTAL_SCAN=${#SCAN_FILES[@]}
SKIPPED=$((TOTAL_STAGED - TOTAL_SCAN))

echo "Scanning $TOTAL_SCAN file(s) ($TOTAL_STAGED staged, $SKIPPED skipped)..."
echo ""

# ==============================================================================
# TIER 1: HARD BLOCK - Real Secrets
# Optimized: file-level grep per pattern (no line-by-line loop, no Python)
# ==============================================================================

echo "â”â”â” Tier 1: Checking for API keys and secrets..."

TIER1_BLOCKED=false

# Combined quick-check pattern (fast path: single grep to see if any file needs deep scan)
TIER1_COMBINED='sk-ant-api03-[A-Za-z0-9_-]{95}|sk-[a-zA-Z0-9]{48,51}|AIza[A-Za-z0-9_-]{35}|hf_[A-Za-z0-9]{32,}|r8_[A-Za-z0-9]{40}|ghp_[A-Za-z0-9]{36}|gho_[A-Za-z0-9]{36}|AKIA[A-Z0-9]{16}|sk_live_[A-Za-z0-9]{24,}|BEGIN PRIVATE KEY|BEGIN RSA PRIVATE KEY'

CURRENT_FILE=0
for file in "${SCAN_FILES[@]}"; do
    ((++CURRENT_FILE))
    echo "  [$CURRENT_FILE/$TOTAL_SCAN] Scanning: $(basename "$file")"

    # Quick combined check (single grep call per file â€” fast path)
    if ! grep -qE "$TIER1_COMBINED" "$file" 2>/dev/null; then
        continue  # No secrets â†’ skip detailed checks
    fi

    # Detailed pattern checks (only if combined matched)
    check_secret_pattern 'sk-ant-api03-[A-Za-z0-9_-]{95}' "$file" \
        "Real Anthropic API key" "ANTHROPIC_API_KEY" && TIER1_BLOCKED=true

    # OpenAI: sk-{48-51 chars} but NOT sk-ant-
    if grep -qE 'sk-[a-zA-Z0-9]{48,51}' "$file" 2>/dev/null && \
       ! grep -qE 'sk-ant-' "$file" 2>/dev/null; then
        ln=$(grep -nmE 'sk-[a-zA-Z0-9]{48,51}' "$file" 2>/dev/null | head -1 | cut -d: -f1)
        print_error "BLOCKED: Real OpenAI API key in $file:${ln:-?}"
        echo "   Fix: Use process.env.OPENAI_API_KEY"
        TIER1_BLOCKED=true
    fi

    check_secret_pattern 'AIza[A-Za-z0-9_-]{35}' "$file" \
        "Real Google AI API key" "GOOGLE_API_KEY" && TIER1_BLOCKED=true

    check_secret_pattern 'hf_[A-Za-z0-9]{32,}' "$file" \
        "Real Hugging Face token" "HUGGINGFACE_TOKEN" && TIER1_BLOCKED=true

    check_secret_pattern 'r8_[A-Za-z0-9]{40}' "$file" \
        "Real Replicate token" "REPLICATE_API_TOKEN" && TIER1_BLOCKED=true

    check_secret_pattern 'ghp_[A-Za-z0-9]{36}' "$file" \
        "Real GitHub token" "GITHUB_TOKEN" && TIER1_BLOCKED=true

    check_secret_pattern 'gho_[A-Za-z0-9]{36}' "$file" \
        "Real GitHub OAuth token" "GITHUB_TOKEN" && TIER1_BLOCKED=true

    check_secret_pattern 'AKIA[A-Z0-9]{16}' "$file" \
        "Real AWS access key" "AWS_ACCESS_KEY_ID" && TIER1_BLOCKED=true

    check_secret_pattern 'sk_live_[A-Za-z0-9]{24,}' "$file" \
        "Real Stripe secret key" "STRIPE_SECRET_KEY" && TIER1_BLOCKED=true

    check_secret_pattern 'BEGIN PRIVATE KEY' "$file" \
        "Cryptographic private key" "" && TIER1_BLOCKED=true

    check_secret_pattern 'BEGIN RSA PRIVATE KEY' "$file" \
        "RSA private key" "" && TIER1_BLOCKED=true

    # Azure OpenAI (two-pattern check)
    if grep -qiE 'azure.*[a-f0-9]{32}' "$file" 2>/dev/null && \
       grep -qiE 'openai|cognitive' "$file" 2>/dev/null; then
        ln=$(grep -nimE 'azure.*[a-f0-9]{32}' "$file" 2>/dev/null | head -1 | cut -d: -f1)
        print_error "BLOCKED: Potential Azure OpenAI key in $file:${ln:-?}"
        echo "   Fix: Use process.env.AZURE_OPENAI_KEY"
        TIER1_BLOCKED=true
    fi
done

# Check blocked file types
for file in $STAGED_FILES; do
    filename=$(basename "$file")

    if [[ "$filename" == ".env" ]] || \
       [[ "$filename" == ".env.local" ]] || \
       [[ "$filename" == ".env.production" ]] || \
       [[ "$filename" == ".env.development" ]]; then
        print_error "BLOCKED: Environment file detected: $file"
        TIER1_BLOCKED=true
    fi

    if [[ "$file" =~ \.(pem|key|p12|pfx)$ ]]; then
        print_error "BLOCKED: Private key file: $file"
        TIER1_BLOCKED=true
    fi

    if [[ "$filename" == "credentials.json" ]] || [[ "$filename" == "secrets.json" ]]; then
        print_error "BLOCKED: Credentials file: $file"
        TIER1_BLOCKED=true
    fi
done

if [ "$TIER1_BLOCKED" == "true" ]; then
    HARD_BLOCKED=true
    echo ""
    echo "  Summary: Secrets detected â€” commit blocked"
else
    echo ""
    echo "  Summary: No secrets in $TOTAL_SCAN file(s) âœ“"
fi
echo ""

# ==============================================================================
# TIER 2: WARNING + CHOICE - Suspicious Patterns
# Scans only source code files (.js/.ts/.json/.sh/.yml etc)
# ==============================================================================

echo "â”â”â” Tier 2: Checking for suspicious patterns..."

for file in "${SOURCE_FILES[@]}"; do
    # Read line-by-line only for Tier 2 (user prompts require line context)
    line_num=0
    while IFS= read -r line || [ -n "$line" ]; do
        ((++line_num))

        has_bypass_comment "$line" && continue

        # Skip pure comment lines
        if [[ "$line" =~ ^[[:space:]]*(//|#|\*) ]]; then
            continue
        fi

        # Generic API_KEY assignment
        if echo "$line" | grep -qiE '[^a-z_]API_?KEY["\x27]\s*:\s*["\x27][A-Za-z0-9_-]{16,}["\x27]' || \
           echo "$line" | grep -qiE '[^a-z_]API_?KEY\s*=\s*["\x27][A-Za-z0-9_-]{16,}["\x27]'; then

            echo "$line" | grep -qiE 'your.?key|example|placeholder|xxx|test|demo|fake|sample' && continue

            print_warning "Suspicious API key assignment in $file:$line_num"
            ((WARNINGS_COUNT++))

            if ! ask_user_confirmation "Possible hardcoded API key detected"; then
                HARD_BLOCKED=true
                break
            fi
        fi

        # Bearer tokens
        if echo "$line" | grep -qE 'Bearer [A-Za-z0-9_-]{20,}'; then
            echo "$line" | grep -qiE 'example|placeholder|xxx|your.?token' && continue

            print_warning "Suspicious Bearer token in $file:$line_num"
            ((WARNINGS_COUNT++))

            if ! ask_user_confirmation "Possible hardcoded Bearer token detected"; then
                HARD_BLOCKED=true
                break
            fi
        fi

        # Database connection strings with credentials
        if echo "$line" | grep -qE '(postgres|mysql|mongodb)://[^:]+:[^@]{8,}@'; then
            echo "$line" | grep -qiE 'example|localhost|127\.0\.0\.1|password|user' && continue

            print_warning "Database connection string in $file:$line_num"
            ((WARNINGS_COUNT++))

            if ! ask_user_confirmation "Possible database credentials in connection string"; then
                HARD_BLOCKED=true
                break
            fi
        fi

    done < "$file"

    [ "$HARD_BLOCKED" == "true" ] && break
done
echo ""

# ==============================================================================
# LANG-CRITICAL & RUSSIAN TRACKERS
# Optimized: file-level grep, parallel execution via temp files
# Fix: .md and rule files excluded (they contain ".ru" in rule text â€” not violations)
# ==============================================================================

# Files to SKIP for LANG-CRITICAL:
# - .md files (rule documentation â€” intentionally mention .ru in "don't use .ru" rules)
# - .cursorrules (same reason)
# - Known security/config files that define the banned patterns
is_lang_excluded() {
    local file="$1"

    # Skip all .md files (rule documentation)
    [[ "$file" == *.md ]] && return 0

    # Skip rule files
    [[ "$file" == *.cursorrules ]] && return 0
    [[ "$file" == *.continuerules ]] && return 0
    [[ "$file" == *.mdc ]] && return 0

    # Skip known false-positive files
    local LANG_ALWAYS_SKIP=(
        "scripts/pre-commit"
        "scripts/pre-commit.js"
        "scripts/pre-commit.ps1"
        ".git/hooks/pre-commit"
        "scripts/seo-check.sh"
        ".ai/forbidden-trackers.json"
        ".ai/security-policy.json"
        ".ai/ai-protection-policy.json"
        ".ai/prompt-injection-patterns.json"
        ".ai/pii-patterns.json"
        ".ai/contexts/"
        ".ai/rules/"
        ".ai/docs/"
        ".claude/"
        "AGENTS.md"
        "README.md"
    )

    for pattern in "${LANG_ALWAYS_SKIP[@]}"; do
        [[ "$file" == *"$pattern"* ]] && return 0
    done

    return 1
}

echo "â”â”â” LANG-CRITICAL: Checking for Russian locale patterns..."

LANG_PATTERNS=(
    '\.ru[^a-zA-Z0-9_-]'
    'ru-RU'
    'ru_RU'
    '"ru"'
)

for file in "${SCAN_FILES[@]}"; do
    is_lang_excluded "$file" && continue

    for pattern in "${LANG_PATTERNS[@]}"; do
        if grep -qE "$pattern" "$file" 2>/dev/null; then
            ln=$(grep -nE "$pattern" "$file" 2>/dev/null | head -1 | cut -d: -f1)
            print_error "LANG-CRITICAL violation in: $file:${ln:-?}"
            echo "   Pattern: $pattern"
            VIOLATIONS_FOUND=true
        fi
    done
done

echo "â”â”â” Checking for Russian tracking services..."

# Files to skip for tracker check
is_tracker_excluded() {
    local file="$1"
    local TRACKER_SKIP=(
        ".ai/forbidden-trackers.json"
        ".ai/security-policy.json"
        ".ai/ai-protection-policy.json"
        ".ai/pii-patterns.json"
        "scripts/seo-check.sh"
        "scripts/pre-commit"
        "RULES_PRODUCT.md"
        "README.md"
    )
    for pattern in "${TRACKER_SKIP[@]}"; do
        [[ "$file" == *"$pattern"* ]] && return 0
    done
    return 1
}

TRACKER_PATTERNS=(
    "metrika\\.yandex"
    "mc\\.yandex"
    "top\\.mail\\.ru"
    "vk\\.com/js/api"
    "vk\\.com/pixel"
    "VK\\.Retargeting"
    "yookassa"
    "kassa\\.yandex"
    "api-maps\\.yandex"
    "2gis"
    "wildberries"
    "ozon\\.ru"
)

for file in "${SCAN_FILES[@]}"; do
    is_tracker_excluded "$file" && continue

    for pattern in "${TRACKER_PATTERNS[@]}"; do
        if grep -qiE "$pattern" "$file" 2>/dev/null; then
            ln=$(grep -inE "$pattern" "$file" 2>/dev/null | head -1 | cut -d: -f1)
            print_error "RUSSIAN TRACKER detected in: $file:${ln:-?}"
            echo "   Pattern: $pattern"
            TRACKERS_FOUND=true
        fi
    done
done

# ==============================================================================
# AI PROTECTION (v9.0+)
# ==============================================================================

echo "â”â”â” AI Protection: Checking for threats..."

AI_PROTECTION_FAILED=false

if [ -f ".ai/ai-protection-policy.json" ]; then
    echo ""
    echo "ğŸ¤– AI Protection v9.1.1"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    # Check 1: Prompt injection in staged files
    echo "â”â”â” Checking for prompt injection..."
    PI_FOUND=false
    STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null || echo "")
    while IFS= read -r f; do
        [ -z "$f" ] && continue
        file "$f" 2>/dev/null | grep -q "binary" && continue
        [ ! -f "$f" ] && continue
        echo "$f" | grep -qE "\.(md|test\.|spec\.)" && continue
        if grep -inE "(AI|SYSTEM|CLAUDE|GPT)[[:space:]]*(INSTRUCTION|OVERRIDE|COMMAND)[[:space:]]*:|ignore[[:space:]]+(all[[:space:]]+)?(previous|prior)[[:space:]]+(instructions?|rules?)|(bypass|disable|skip)[[:space:]]+(security|validation|check)" "$f" > /dev/null 2>&1; then
            LINE=$(grep -inE "(AI|SYSTEM|CLAUDE|GPT)[[:space:]]*(INSTRUCTION|OVERRIDE|COMMAND)[[:space:]]*:|ignore[[:space:]]+(all[[:space:]]+)?(previous|prior)[[:space:]]+(instructions?|rules?)|(bypass|disable|skip)[[:space:]]+(security|validation|check)" "$f" | head -n1 | cut -d: -f1)
            echo -e "${RED}ğŸš¨ Prompt injection in $f:$LINE${NC}"
            PI_FOUND=true
            AI_PROTECTION_FAILED=true
        fi
    done <<< "$STAGED_FILES"
    [ "$PI_FOUND" = false ] && echo -e "${GREEN}âœ“ No prompt injection detected${NC}"

    # Check 2: PII in AI logs
    echo "â”â”â” Checking for PII in AI logs..."
    PII_FOUND=false
    for ai_file in ".ai/token-limits.json" ".ai/audit-trail.log"; do
        [ ! -f "$ai_file" ] && continue
        COUNT=$(grep -oE "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}" "$ai_file" 2>/dev/null | grep -v "example.com\|noreply@" | wc -l | tr -d ' ')
        [ "$COUNT" -gt 0 ] && echo -e "${YELLOW}âš   PII (${COUNT} email(s)) in $ai_file${NC}" && PII_FOUND=true
        COUNT=$(grep -ocE "\+380[0-9]{9}" "$ai_file" 2>/dev/null | tr -d ' ')
        [ "$COUNT" -gt 0 ] && echo -e "${YELLOW}âš   PII (${COUNT} phone(s)) in $ai_file${NC}" && PII_FOUND=true
    done
    [ "$PII_FOUND" = false ] && echo -e "${GREEN}âœ“ No PII detected in AI logs${NC}"

    # Check 3: .ai/ directory protection
    echo "â”â”â” Checking .ai/ directory protection..."
    GI_FAIL=false
    for entry in ".ai/audit-trail.log" ".ai/.ai-protection-cache/" "ai-logs/"; do
        grep -q "^${entry}$" .gitignore 2>/dev/null || { echo -e "${RED}âŒ Missing in .gitignore: $entry${NC}"; GI_FAIL=true; AI_PROTECTION_FAILED=true; }
    done
    [ "$GI_FAIL" = false ] && echo -e "${GREEN}âœ“ .ai/ directory properly protected${NC}"

    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    if [ "$AI_PROTECTION_FAILED" = false ]; then
        echo -e "${GREEN}âœ… AI PROTECTION PASSED${NC}"
    fi
fi

# ==============================================================================
# DUAL-STRUCTURE SYNC CHECK (WARNING ONLY â€” does not block commit)
# Verifies that rule-file pairs (dev â†” npm-templates) are staged together.
# Silent on unrelated commits. Warns only when one side is staged without the other.
# ==============================================================================

echo "â”â”â” Dual-structure sync check..."

SYNC_WARN=false

check_sync_pair() {
    local dev_file="$1"
    local npm_file="$2"
    local dev_staged npm_staged

    echo "$STAGED_FILES" | grep -qF "$dev_file" && dev_staged=true || dev_staged=false
    echo "$STAGED_FILES" | grep -qF "$npm_file" && npm_staged=true || npm_staged=false

    if [ "$dev_staged" == "true" ] && [ "$npm_staged" == "false" ]; then
        echo -e "${YELLOW}âš ï¸  Sync: $dev_file staged but $npm_file was not${NC}"
        SYNC_WARN=true
    fi
    if [ "$npm_staged" == "true" ] && [ "$dev_staged" == "false" ]; then
        echo -e "${YELLOW}âš ï¸  Sync: $npm_file staged but $dev_file was not${NC}"
        SYNC_WARN=true
    fi
}

# Script pairs (both tracked in root + npm-templates) â€” must stay in sync
# Note: .claude/, .cursor/, AGENTS.md etc are gitignored dev copies â€” not tracked, skip
check_sync_pair "scripts/pre-commit"             "npm-templates/scripts/pre-commit"
check_sync_pair "scripts/post-push.sh"           "npm-templates/scripts/post-push.sh"

if [ "$SYNC_WARN" == "true" ]; then
    echo -e "${YELLOW}   Tip: stage the npm-templates counterpart to keep distribution in sync.${NC}"
    echo -e "${YELLOW}   Commit will PROCEED â€” this is a warning, not a block.${NC}"
else
    echo "  âœ“ Sync OK"
fi
echo ""

# ==============================================================================
# FINAL VERDICT
# ==============================================================================

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

if [ "$VIOLATIONS_FOUND" == "true" ]; then
    echo -e "${YELLOW}âš ï¸  LANG-CRITICAL WARNINGS DETECTED${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "Russian content patterns detected."
    echo -e "${YELLOW}Commit will PROCEED (this is a warning)${NC}"
    echo ""
fi

if [ "$HARD_BLOCKED" == "true" ]; then
    echo -e "${RED}âŒ COMMIT BLOCKED${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ğŸš¨ Your commit contains sensitive data or was cancelled."
    echo ""
    [ "$IS_CI" == "true" ] && echo "Running in CI/CD: Set SECURITY_HOOK_MODE=permissive to bypass tier 2"
    echo ""
    log_to_audit_trail "HARD_BLOCK" "Secrets detected or user cancellation"
    exit 1
fi

if [ "$TRACKERS_FOUND" == "true" ]; then
    echo -e "${RED}âŒ COMMIT BLOCKED - RUSSIAN TRACKERS${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    log_to_audit_trail "RUSSIAN_TRACKERS" "Trackers detected"
    exit 1
fi

if [ "$AI_PROTECTION_FAILED" == "true" ]; then
    echo -e "${RED}âŒ COMMIT BLOCKED - AI PROTECTION${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ğŸ¤– AI Protection detected threats (prompt injection, PII, .ai/ violations)"
    echo ""
    log_to_audit_trail "AI_PROTECTION" "AI threats detected"
    exit 1
fi

echo -e "${GREEN}âœ… SECURITY SCAN PASSED${NC}"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

if [ $WARNINGS_COUNT -gt 0 ]; then
    print_success "No critical issues (user confirmed $WARNINGS_COUNT warning(s))"
else
    print_success "No secrets or trackers detected"
fi

echo ""

# Code quality check (non-blocking)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SCRIPT_DIR/pre-commit-lint.sh" ]; then
    bash "$SCRIPT_DIR/pre-commit-lint.sh" || true
fi

echo "Proceeding with commit..."
echo ""
exit 0
